import sys
from typing import Iterable, List, Set, Generator, TextIO, Tuple, Any, Deque
from pathlib import Path
import argparse
import warnings
import shutil as sh
from collections import deque

from zipfile import ZipFile
import MDAnalysis as mda
import parmed as pmd


def check_input(args: Any) -> Tuple[Path, Path, int, int]:
    top = Path(args.topology)
    assert top.is_file()
    coords = Path(args.coordinates)
    assert coords.is_file()
    posre = args.posre
    assert 1 < posre < 9999, f"Invalid posre value ({posre}). Set a value between 1 and 9999."
    posre_wat = args.posre_wat
    assert 1 < posre_wat < 9999, f"Invalid posre_wat value ({posre_wat}). Set a value between 1 and 9999."
    return top, coords, posre, posre_wat


def get_posres_include(mol_name: str, target_chains: Iterable[str], binder_chains: Iterable[str]) -> str:
    # I may decide to add different POSRES to target and binder.
    posres_define = "POSRES_WATER"
    if mol_name in target_chains:
        posres_define = f"POSRES"
    elif mol_name in binder_chains:
        posres_define = f"POSRES"

    posres_include_text = f"""; Include Position restraint file
#ifdef {posres_define}
#include "posre_{mol_name}.itp"
#endif

    """
    return posres_include_text


def chunk(f: TextIO) -> Generator:
    linea = " "
    while linea != "":
        text: List[str] = []
        while True:
            cursor = f.tell()
            linea = f.readline()
            mol_start = linea[:16] == "[ moleculetype ]"
            last_mol_end = linea[:10] == "[ system ]"
            if (mol_start or last_mol_end) and len(text) > 0:
                f.seek(cursor)
                break
            elif linea == "":
                break
            else:
                text.append(linea)
        yield text


def fixup_top(top_path: Path,
              name: str,
              *,
              target_chains: Iterable[str],
              binder_chains: Iterable[str],
              posre: float,
              posre_wat: float
              ) -> None:
    local_dir = top_path.parent
    # Backup topology
    norestr_name = "norestr_" + top_path.name.split(".")[0] + ".top"
    sh.copy(top_path, local_dir / norestr_name)

    # Get the topology of each molecule
    with open(top_path, "r") as file:
        chunker = chunk(file)
        header_top: List[str] = next(chunker)

        mols_top_text: List[List[str]] = []
        for text in chunker:
            mols_top_text.append(text)

        bottom_top: List[str] = mols_top_text.pop()

    # Write out the topology of each molecule in its dedicated itp
    mol_itp_files = {}
    solvent: Set[str] = {"SOL", "WAT"}
    ions: Set[str] = {"NA", "Na", "CL", "Cl"}
    chainIDs: Deque[str] = deque(target_chains + binder_chains)  # type: ignore
    for mol_text in mols_top_text:
        # Proteins chains are named 'systemN' where N is the chain number.
        # Small ligands take their resname as a segment identifier, and their chainID is discarded (parmed stuff),
        # hence I'm forced to detect chains as solvent (water/ions) and if not, assume they're ordered as the
        # user input them on the config file (eg:[A, B, C, D], with A and B being the target and C D being the binder).
        # I'm also assuming the names of the solvent and the ions.
        mol_name_old = mol_text[2][:10].strip()
        if mol_name_old in solvent or mol_name_old in ions:
            mol = mol_name_old
        else:
            mol = chainIDs.popleft()
            # mol(chainID) should be just a char, but just in case:
            mol_text[2] = f"{mol}{3: >{21 - len(mol)}}" "\n"

        mol_itp_files[mol] = Path(local_dir, f"{mol}.itp")
        with open(mol_itp_files[mol], "w") as file:
            for line in mol_text:
                file.write(line)

    # Open them with MDA, select the heavy atoms and write the posres_.itp restraints files
    header = """;automatically generated by LOCUAZ

    [ position_restraints ]
    ; atom  type      fx      fy      fz
"""
    wat_header = f"""automatically generated by LOCUAZ
    [ position_restraints ]
    ;  i funct       fcx        fcy        fcz
       1    1       {posre_wat:>4}       {posre_wat:>4}       {posre_wat:>4}
"""
    ion_text = f"""     1     1  {posre_wat:>4}  {posre_wat:>4}  {posre_wat:>4}
"""
    mol_posres_files = {}
    complex_chains: Set[str] = set(target_chains + binder_chains)  # type: ignore
    for mol, mol_path in mol_itp_files.items():
        mol_posres_files[mol] = Path(mol_path.parent, f"posre_{mol}.itp")
        file = open(mol_posres_files[mol], "w")

        if mol in complex_chains:
            file.write(header)
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                u = mda.Universe(str(mol_path))
            at = u.select_atoms("not type H and not type H?")
            for a in at:
                file.write(f"{a.id:>6d}     1  {posre:>4}  {posre:>4}  {posre:>4}" "\n")
        elif mol in solvent:
            file.write(wat_header)
        elif mol in ions:
            file.write(header)
            file.write(ion_text)
        else:
            warnings.warn(
                f"Writing {mol}'s topology as if it was an ion. Check if it's ok."
            )
            file.write(header)
            file.write(ion_text)
        file.close()

    # Add posres_.itp include on each molecule.itp
    for mol, mol_path in mol_itp_files.items():
        with open(mol_path, "a") as file:
            file.write(get_posres_include(mol, target_chains, binder_chains))

    includes_top = ["; Include chain topologies" "\n"]
    for mol_path in mol_itp_files.values():
        includes_top.append(f'#include "{mol_path.name}"' "\n")

    # create INCLUDES FOR THE molecules.itp, merge [ header_top ; includes_top ; bottom_top ] and write main top file
    chainIDs: Deque[str] = deque(target_chains + binder_chains)  # type: ignore
    with open(top_path, "w") as file:
        for line in header_top + ["\n"] + includes_top:
            file.write(line)
        itera_file = iter(bottom_top)
        while True:
            line = next(itera_file)
            file.write(line)
            if line[0:22] == "; Compound       #mols":
                break
        while True:
            try:
                line = next(itera_file)
            except StopIteration:
                break
            # rewrite 'system1', 'system2', ... with the proteins chainIDs
            # if line[:6] == "system":
            mol_name_old = line[:10].strip()
            if mol_name_old in solvent or mol_name_old in ions:
                pass
            else:
                # if molecule name doesn't look like water or ions, then assume
                # it's either target or binder. Rename it to 'A', 'B', ...
                chainID = chainIDs.popleft()
                # chainID should be just a char, but just in case:
                line = f"{chainID}{1: >{22 - len(chainID)}}" "\n"
            file.write(line)

    # compress everything on a zip file
    zip_top_path = Path(local_dir, f"{name}.zip")
    with ZipFile(zip_top_path, mode="w") as zf:
        zf.write(top_path, arcname=f"{name}.top")
        for mol, mol_path in mol_itp_files.items():
            zf.write(mol_path, arcname=f"{mol}.itp")
        for mol, posres_path in mol_posres_files.items():
            zf.write(posres_path, arcname=f"posre_{mol}.itp")

    return


def amb_to_gmx(
        prmtop: Path,
        rst: Path,
        *,
        target_chains: Iterable[str],
        binder_chains: Iterable[str],
        posre: float,
        posre_wat: float
) -> None:
    local_dir = prmtop.parent
    name = prmtop.stem
    amb = pmd.load_file(str(prmtop), str(rst))
    # amb_pdb = pmd.load_file(str(pdb))
    # amb.box = amb_pdb.box

    gro_path = Path(local_dir, f"{name}.gro")
    top_path = Path(local_dir, f"{name}.top")
    amb.save(str(gro_path))
    amb.save(str(top_path))

    fixup_top(
        top_path,
        name,
        target_chains=target_chains,
        binder_chains=binder_chains,
        posre=posre,
        posre_wat=posre_wat,
    )


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p",
        "--topology",
        type=str,
        required=True,
        help="topology in .prmtop format.",
    )
    parser.add_argument(
        "-c",
        "--coordinates",
        type=str,
        required=True,
        help="coordinates in .rst7 format.",
    )
    parser.add_argument(
        "-t",
        "--target_chains",
        type=str,
        required=True,
        nargs='+',
        help="space separated list of the target chainIDs. Eg: A B",
    )
    parser.add_argument(
        "-b",
        "--binder_chains",
        type=str,
        required=True,
        nargs='+',
        help="space separated list of the binder chainIDs. Eg: C D",
    )
    parser.add_argument(
        "-r",
        "--posre",
        type=int,
        default=1000,
        required=False,
        help="positional restraints for the target and binder. Takes values between 1 and 9999",
    )
    parser.add_argument(
        "-w",
        "--posre_wat",
        type=int,
        default=1000,
        required=False,
        help="positional restraints for water and ions. Takes values between 1 and 9999",
    )

    args = parser.parse_args()

    top, coords, posre, posre_wat = check_input(args)

    amb_to_gmx(top, coords, target_chains=args.target_chains, binder_chains=args.binder_chains, posre=posre,
               posre_wat=posre_wat)


if __name__ == "__main__":
    sys.exit(main())
